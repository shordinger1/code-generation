import os.path
import subprocess

from Agent.minecraft.static_files import get_root
from java_grammar.JavaAnalyzer import analysis_java_file
from chat.client import generation
from chat.model import code_generation, prompt_code_generation, prompt_code_reflection
from util import get_logger

LOG = get_logger()


class java_template_class:

    def __init__(self, project_root: str, class_name: str, package: str):
        class_name = ''.join(words.capitalize() for words in class_name.split(' ')) if ' ' in class_name else class_name

        self.project_root = project_root
        self.class_name = class_name
        self.package = package
        self.imports = []
        self.code = None
        self.inited = False
        self.class_path = os.path.join(project_root, 'src', 'main', 'java', self.package)
        self.file_path = self.class_path + '/' + self.class_name + '.java'
        # self.read_from_file()
        print(f'java class inited as {class_name} in {self.class_path}')

    def write_to_file(self):
        os.makedirs(self.class_path, exist_ok=True)
        with open(self.file_path, "w", encoding='utf-8') as f:
            f.write(self.formatted_code())

    def read_from_file(self):
        if os.path.exists(self.file_path):
            with open(self.file_path, 'r', encoding='utf-8') as f:
                self.package, self.imports, self.code = split_java_file(f.read())
                self.inited = True
        else:
            self.inited = False

    def formatted_code(self):
        if self.code is None:
            return None
        package = self.package.replace('\\', '.').replace('/', '.')
        code = f"package {package};\n"
        for impt in self.imports:
            code += f"{impt}\n"
        code += f"{self.code}\n"
        return code

    def add_import(self, *imports):
        for impt in imports:
            if impt not in self.imports:
                self.imports.append(impt)
        return self

    def init_code(self, code):
        self.code = code

    def syntax_check(self):
        res, msg = analysis_java_file(self.file_path)
        if not res:
            LOG.write(f"syntax check failed while checking {self.file_path} \n Errors:\n {msg}")
        return res, msg

    def build_project(self):
        error = None
        try:
            result = subprocess.run(
                [f'{get_root()}/gradlew.bat', 'build'],
                cwd=get_root(),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,  # 分别捕获 stdout/stderr
                text=True,
                check=True
            )
            error = result.stderr
        except subprocess.CalledProcessError as e:
            error = e.stderr  # 失败时返回已捕获的输出
        return self.error_analysis(error)

    # 使用示例
    def error_analysis(self, error):
        # TODO
        return True, error

    def get_template(self):
        return None

    def process(self, description):
        LOG.write(f"START AUTO PROCESSING FOR {self.file_path}:\n TASK DESCRIPTION:{description}\n processing:\n")
        if self.code is None:
            LOG.write("No template generated file detected, will generated by LLM\n")
        template_code = self.get_template()
        rag_code = None  # TODO
        if template_code is None:
            LOG.write("No template code detected, ignored\n")
        if rag_code is None:
            LOG.write("No RAG code detected, ignored\n")
        prompt = prompt_code_generation(description, self.formatted_code(), template_code, rag_code)
        chat_result = generation(prompt, code_generation)
        self.package = chat_result.package
        self.imports = chat_result.imports
        self.code = chat_result.contents
        self.write_to_file()
        retry = 0
        MAX_RETRY = 3
        res, msg = self.syntax_check()
        while retry < MAX_RETRY and res:
            retry += 1
            LOG.write(f"syntax Error occurred, retry with reflection module! retry:{retry}")
            prompt = prompt_code_reflection(description, msg, self.formatted_code(), template_code, rag_code)
            chat_result = generation(prompt, code_generation)
            self.package = chat_result.package
            self.imports = chat_result.imports
            self.code = chat_result.contents
            self.write_to_file()
            res, msg = self.syntax_check()
        retry = 0
        res, msg = self.build_project()
        while retry < MAX_RETRY and res:
            retry += 1
            LOG.write(f"Compile Error occurred, retry with reflection module! retry:{retry}")
            prompt = prompt_code_reflection(description, msg, self.formatted_code(), template_code, rag_code)
            chat_result = generation(prompt, code_generation)
            self.package = chat_result.package
            self.imports = chat_result.imports
            self.code = chat_result.contents
            self.write_to_file()
            res, msg = self.build_project()


def split_java_file(content: str) -> tuple:
    """
    分割Java源代码文件为package、imports和class三部分

    参数:
    content (str): Java源代码字符串

    返回:
    tuple: (package_line, imports_list, class_code)
      - package_line: 字符串，package行（包括换行符），无则为空字符串
      - imports_list: 字符串列表，所有import行（包括换行符）
      - class_code: 字符串，剩余代码
    """
    lines = content.splitlines(keepends=True)  # 保留行尾换行符
    package_line = ""
    imports_list = []
    class_lines = []
    in_import_section = True  # 标志是否仍在import部分

    # 处理package行
    if lines and lines[0].lstrip().startswith('package'):
        package_line = lines[0][7:-2]
        lines = lines[1:]

    # 处理imports和class部分
    for line in lines:
        stripped = line.lstrip()  # 移除行首空白（保留行尾）

        if not in_import_section:
            # 已离开import部分，直接添加到class
            class_lines.append(line)
            continue

        if stripped.startswith('import'):
            # 找到import行
            imports_list.append(line[0:-1])
        elif stripped == '' or stripped.startswith('//') or stripped.startswith('/*'):
            # 空行或注释行，不打断import部分
            class_lines.append(line)
        else:
            # 遇到非import/空行/注释行，进入class部分
            in_import_section = False
            class_lines.append(line)

    class_code = ''.join(class_lines)
    return package_line, imports_list, class_code
